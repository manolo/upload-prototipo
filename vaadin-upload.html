<!--
@license
Copyright (c) 2016 Vaadin. All rights reserved.
This code may only be used under the Apache-2.0 license
-->
<link rel="import" href="../polymer/polymer.html">

<!--
Web component for uploading files to the server.
Example:
    <vaadin-upload target="destination_url"></vaadin-upload>

@demo
-->
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-progress/paper-progress.html">
<link rel="import" href="../iron-icons/iron-icons.html">

<dom-module id="vaadin-upload">

  <style type="text/css">
    .enabled {
      border: 1px dashed #1DB6E4;
      @apply(--vaadin-upload-upload-border-enabled);
    }

    .hover {
      opacity: .7;
      border: 1px dashed #111;
      @apply(--vaadin-upload-upload-border-hover);
    }

    #UploadBorder{
      vertical-align: middle;
      color: #555;
      padding: 20px;
      overflow-y: auto;
      @apply(--vaadin-upload-upload-border);
      @apply(--layout-vertical)
      margin: 10px;
    }

    #dropArea {
      text-align: center;
      @apply(--vaadin-upload-drop-area);
    }

    .file {
      padding: 10px 0px;
      display: table;
      width: 100%;
      @apply(--vaadin-upload-file);
    }

    .commands {
      float: right;
      @apply(--vaadin-upload-commands);
    }

    .commands iron-icon:not([icon="done"]) {
      cursor: pointer;
      opacity: .9;
      @apply(--vaadin-upload-commands-faded);
      color: #03a9f4;
    }
    .commands iron-icon[icon="warning"] {
      color: #f40303;
    }
    .commands iron-icon:hover {
      opacity: 1;
      @apply(--vaadin-upload-commands-hovered);
    }

    [hidden] {
      display: none;
    }

    .fileRow {
      @apply(--layout-horizontal);
      @apply(--layout-center);
    }

    .nameWithStatus {
      @apply(--layout-flex);
      width: 1px;
    }

    .name,
    .error,
    .status {
      text-overflow: ellipsis;
    }

    .name {
      font-size: 14px;
    }
    .error,
    .status {
      font-size: 12px;
      padding-bottom: 3px;
      white-space: nowrap;
      overflow: hidden;
      max-width: 100%;
    }
    .error {
      color: #f40303;
      @apply(--vaadin-upload-status);
    }
    .status {
      @apply(--vaadin-upload-status);
    }

    paper-progress {
      --paper-progress-active-color: #03a9f4;
      width: 100%;
    }

    paper-progress[error] {
      --paper-progress-active-color: #f40303;
    }

    paper-progress[indeterminate] {
      --paper-progress-container-color: #03a9f4;
      --paper-progress-active-color: rgba(1, 97, 155, 0.5);
    }

    paper-progress[uploading][indeterminate] {
      --paper-progress-container-color: #e0e0e0;
      --paper-progress-active-color: grey;
    }

    :host ::content .button, :host ::content .drop {
      display: inline-block;
      line-height: 3em;
    }
    .button {
      cursor: pointer;
    }
  </style>

  <template>
    <div>
      <div id='UploadBorder' flex>
        <content select=".drop"></content>

        <template is="dom-repeat" items="{{files}}">
          <div class="file">
            <div class="fileRow">
              <div class="nameWithStatus">
                <div class="name">{{item.name}}</div>
                <div class="error" hidden$="{{!item.error}}">{{errorText}} : {{item.error}}</div>
                <div class="status" hidden$="{{!item.status}}">{{item.status}}</div>
              </div>
              <div class="commands">
                <iron-icon icon="refresh" title="{{retryText}}" on-click="_retryUpload" hidden$="{{!item.error}}"></iron-icon>
                <iron-icon icon="clear" title="{{removeText}}" on-click="_cancelUpload" hidden$="{{item.complete}}"></iron-icon>
                <iron-icon icon="done" title="{{successText}}" hidden$="{{!item.complete}}"></iron-icon>
                <iron-icon icon="warning" title="{{errorText}}" hidden$="{{!item.error}}"></iron-icon>
              </div>
            </div>
            <div hidden$={{progressHidden}}>
              <paper-progress
                 value$="{{item.progress}}"
                 error$="{{item.error}}"
                 indeterminate$="{{item.indeterminate}}"
                 uploading$="{{item.uploading}}"
                 complete$="{{item.complete}}"
                 ></paper-progress>
            </div>
          </div>
        </template>

        <div class="button" on-click="_fileClick">
          <content select=".button"></content>
        </div>
      </div>
    </div>
    <input type="file" id="fileInput" on-change="_fileChange" hidden multiple="{{multi}}" accept="{{accept}}">
    <!--<paper-toast id="toastSuccess" text="File uploaded successfully!"></paper-toast>
    <paper-toast id="toastFail" text="Error uploading file!"></paper-toast>-->
  </template>

</dom-module>

<script>

  Polymer({

    is: 'vaadin-upload',

     /**
      * Fired when a response is received status code 200.
      *
      * @event upload-success
    */
     /**
      * Fired when a response is received other status code.
      *
      * @event upload-error
    */
    /**
     * Fired when a file is about to be uploaded.
     *
     * @event before-upload
   */

    properties: {

      /**
       * `target` is the target url to upload the files to.
       * Additionally by adding "<name>" in your url, it will be replaced by
       * the file name.
       */
      target: {
        type: String,
        value: ""
      },

      /**
       * `accept` is the set of comma separated file extensions or mime types
       * to filter as accepted.
      */

      accept: {
        type: String,
        value: ""
      },

      /**
       * `progressHidden` indicates whether or not the progress bar should be hidden.
       */
      progressHidden: {
        type: Boolean,
        value: false
      },

      /**
       * `droppable` indicates whether or not to allow file drop.
      */
      droppable: {
        type: Boolean,
        value: false
      },

      /**
       * `dropText` is the  text to display in the file drop area.
      */
      dropText: {
        type: String,
        value: "Drop Files Here"
      },

      /**
       * `multi` indicates whether or not to allow multiple files to be uploaded.
      */
      multi: {
        type: Boolean,
        value: false
      },

      /**
       * `files` is the list of files to be uploaded
      */
      files: {
        type: Array,
        value: function() {
            return [];
        }
      },

      /**
       * `method` is the http method to be used during upload
      */
      method: {
        type: String,
        value: "PUT"
      },

      /**
       * `raised` indicates whether or not the button should be raised
      */
      raised: {
        type: Boolean,
        value: false
      },

      /**
       * `noink` indicates that the button should not have an ink effect
      */
      noink: {
        type: Boolean,
        value: false
      },

      /**
       * `headers` is a key value map of header names and values
      */
      headers: {
        type: Object,
        value: {},
      },

      /**
       * `retryText` is the text for the tooltip to retry an upload
      */
      retryText: {
        type: String,
        value: 'Retry Upload'
      },

      /**
       * `removeText` is the text for the tooltip to remove an upload
      */
      removeText: {
          type: String,
          value: 'Remove'
      },

      /**
       * `successText` is the text for the tooltip of a successful upload
      */
      successText: {
          type: String,
          value: 'Success'
      },

      uploadingText: {
          type: String,
          value: 'Uploading'
      },

      /**
       * `errorText` is the text to display for a failed upload
      */
      errorText: {
          type: String,
          value: 'Error'
      },

      /**
       * `_shownDropText` indicates whether or not the drop text should be shown
      */
      _shownDropText: {
        type: Boolean,
        value: false
      },

      /**
       * How many concurrent uploads can happen at the same time.
       *   0 means no limit
       */
      concurrent: {
        type: Number,
        value: 1
      },

      /**
       * Max file size.
       *  0 means unlimited
       */
      maxFileSize: {
        type: Number,
        value: 0
      },

      errorHandler: {
        type: Function,
        value: function() {
          return function() {}
        }
      },

      timeout: {
        type: Number,
        value: 0
      },

      noauto: {
        type: Boolean,
        value: false
      }

    },

    /**
     * Clears the list of files
    */
    clear: function() {
      for (var i = 0; i < this.files.length; i++) {
        var file = this.files[i];
        if (file.xhr) {
          file.xhr.abort();
        }
      }
      this.set("files", []);
      this._showDropText();
    },

    ready: function() {
      if (this.raised) {
        this.toggleAttribute("raised", true, this.$.button);
      }
      if (this.noink) {
        this.toggleAttribute("noink", true, this.$.button);
      }
      if (this.droppable && !this._touchDevice()) {
        this._showDropText();
        this.setupDrop();
      } else {
        Polymer.dom(this).querySelector('.drop').style.display = 'none';
      }
    },

    /**
     * A function to set up a drop area for drag-and-drop file uploads
    */
    setupDrop: function() {
      var uploadBorder = this.$.UploadBorder;
      this.toggleClass("enabled", true, uploadBorder);

      this.ondragover = function(e) {
        e.stopPropagation();
        this.toggleClass("hover", true, uploadBorder);
        return false;
      }

      this.ondragleave = function() {
        this.toggleClass("hover", false, uploadBorder);
        return false;
      }

      this.ondrop = function(event) {
        this.toggleClass("hover", false, uploadBorder);
        event.preventDefault();
        var length = event.dataTransfer.files.length;
        for (var i = 0; i < length; i++) {
          var file = event.dataTransfer.files[i];
          // Check if multiple upload is allowed
          if (!this.multi && this.files.length !== 0) {
            return;
          }
          this._addFile(file);
        }
        if (!this.noauto) this._filesChanged();
      }
    },

    /**
     * Clicks the invisible file input
    */
    _fileClick: function(e) {
      // TODO WEAK
      var l = e.srcElement.classList;
      if (!l || !l.contains('small')) {
        l = e.srcElement.parentElement.classList;
      }
      if (l && l.contains('small')) {
        if (l.contains('add')) {
        } else if (l.contains('start')) {
          this._filesChanged();
          return;
        } else if (l.contains('cancel')) {
          this.clear();
          return;
        } else if (l.contains('pause')) {
          for (var i = 0; i < this.files.length; i++) {
            var file = this.files[i];
            if (file.uploading && file.xhr) {
              file.abort = true;
              file.xhr.abort();
            }
          }
          return;
        } else if (l.contains('resume')) {
          this._filesChanged();
          return;
        }
      }

      var elem = this.$.fileInput;
      if (elem && document.createEvent) { // sanity check
        var evt = document.createEvent("MouseEvents");
        evt.initEvent("click", true, false);
        elem.dispatchEvent(evt);
      }
    },

    /**
     * Called whenever input file element changes.
    */
    _fileChange: function(e) {
      var length = e.target.files.length;
      for (var i = 0; i < length; i++) {
        var file = e.target.files[i];
        this._addFile(file);
      }
      if (!this.noauto) this._filesChanged();
    },

    _addFile: function(file) {
      // Check if filetype is accepted
      var mimeType = ((file.type !== '') ? file.type.match(/^[^\/]*\//)[0] : null);
      var fileType = file.name.match(/\.[^\.]*$/)[0];
      if (this.accept !== '' && !(this.accept.indexOf(mimeType) > -1 || this.accept.indexOf(fileType) > -1)) {
        return;
      }
      if (this.maxFileSize > 0 && file.size > this.maxFileSize) {
        return;
      }

      this.fire("upload-file-added", {file:file});
      file.uploading = false;
      file.progress = 0;
      file.error = false;
      file.complete = false;
      this.push("files", file);
    },

    _filesChanged: function() {
      for (var i = 0, j = 0; i < this.files.length && j < this.concurrent; i++) {
        var file = this.files[i]
        if (!file.uploading && file.progress < 100) {
          this.uploadFile(file);
        }
        if (file.uploading) {
          j++;
        }
      }
    },

    /**
     * Cancels the file upload for a specific file
     *
     * @param {object} a file, an element of the files array
    */
    cancel: function(file) {
      if (file) {
        if (file.xhr) {
          file.xhr.abort();
        }
        this.splice("files", this.files.indexOf(file), 1);
        this._showDropText();
        this._filesChanged();
      }
    },

    /**
     * Cancels the file upload
     *
     * @param {object}, an event object
    */
    _cancelUpload: function(e) {
      this.cancel(e.model.__data__.item);
    },

    /**
     * Retries to upload the file
     *
     * @param {object}, an event object
    */
    _retryUpload: function(e) {
      e.model.set("item.error", undefined);
      e.model.set("item.progress", 0);
      e.model.set("item.status", undefined);
      e.model.set("item.abort", undefined, true);
      // The async helps give visual feedback of a retry occurring, even though it's less efficient.
      this.async(function() {
        this.uploadFile(e.model.__data__.item);
      }.bind(this), 50);
    },

    /**
     * Whether or not to display the drop text
    */
    _showDropText: function() {
      this.set("_shownDropText", (!this.files.length && this.droppable));
    },
    _touchDevice: function() {
      try {
        document.createEvent('TouchEvent');
        return true;
      } catch (e) {
        return false;
      }
    },

    /**
     * Set a property to an item using Polymer so as it is observed.
     */
    _set: function(file, prop, val, updateStyles) {
      var str = "files." + this.files.indexOf(file) + "." + prop;
      this.set(str, val);
      if (updateStyles) {
        this.updateStyles();
      }
    },

    /**
     * Uploads a file
     *
     * @param {object} a file, an element of the files array
    */
    uploadFile: function(file) {
      if (!file) {
        return;
      }
      this.fire('upload-started', {file:file});
      this._showDropText();

      var formData = new FormData();
      formData.append("file", file, file.name);

      var ini = new Date().getTime();
      var last = ini;
      var xhr = file.xhr = new XMLHttpRequest();
      var stalledId;
      // onprogress is called always after onreadystatechange
      xhr.upload.onprogress = function(e) {
        clearTimeout(stalledId);
        if (file.error) return;

        var done = e.loaded, total = e.total, progress = ~~(done/total*100);
        this._set(file, "transferred", done);
        this._set(file, "progress", progress);

        last = new Date().getTime();
        var ellapsed = (last - ini) / 1000;
        var rem = 1 + ~~(ellapsed * (100 / progress - 1));
        this._set(file, "remaining", rem);

        var totalStr = total > (1024*1024) ? ((~~(total/1024/1024*10)/10) + " MB") : (~~(total/1024) + " KB");
        var doneStr = done > (1024*1024) ? ((~~(done/1024/1024*10)/10) + " MB") : (~~(done/1024) + " KB");
        this._set(file, "totalStr", totalStr);
        this._set(file, "doneStr", doneStr);
        var speed = ~~(total / ellapsed / 1024);
        this._set(file, "speed", speed);

        var status = file.totalStr + " (" + file.progress + "%)" ;

        if (file.abort) {
          this._set(file, "status", status + " paused.");
        } else {
          this._set(file, "status", status + " about " + file.remaining + " seconds remaining.");
        }
        if (done >= total) {
          this._set(file, "status", "File processing", true);
          this._set(file, "uploading", undefined, true);
          clearTimeout(stalledId);
          this._filesChanged();
        }
        this._set(file, "indeterminate", done <= 0 || done >= total, true);
        this.fire("upload-progress", {file: file});

        stalledId = setTimeout(function() {
          if (file.uploading)
             this._set(file, status + " stalled ");
        }.bind(this), 2000);

      }.bind(this);

      var url = this.target.replace("<name>", file.name);
      xhr.open(this.method, url, true);

      if (typeof this.headers == 'string') {
        try {
          this.headers = JSON.parse(this.headers);
        } catch (e) {
          this.headers = undefined;
        }
      }
      for (key in this.headers) {
        xhr.setRequestHeader(key, this.headers[key]);
      }

      if (this.timeout) {
        xhr.timeout = this.timeout;
      }

      // More reliable than xhr.onload
      xhr.onreadystatechange = function(e) {
        clearTimeout(stalledId);

        // We are not interested in states previous to 4
        if (xhr.readyState != 4) {
          return;
        }

        this._set(file, "indeterminate", undefined);
        this._set(file, "uploading", undefined);
        this._set(file, "status", undefined);
        if (file.abort) {
          this._set(file, "error", undefined);
          this._set(file, "complete", undefined);
          this._set(file, "progress", 0, true);

          return;
        }
        var error = this.errorHandler(file, xhr);
        if (!error) {
          if (xhr.status == 0) error = 'Server Unavailable';
          else if (xhr.status > 500) error = 'Unexpected Server Error';
          else if (xhr.status > 400) error = 'Forbiden';
        }
        this._set(file, "error", error);
        this._set(file, "complete", !error);
        this._set(file, "progress", 100, true);
        this.fire("upload-" + (error ? "error" : "success"), {file: file, xhr: xhr});
        this._filesChanged();
      }.bind(this);

      this._set(file, "status", "Connecting");
      this._set(file, "uploading", true);
      this._set(file, "indeterminate", true);
      this._set(file, "abort", undefined);
      this._set(file, "uploading", true, true);
      xhr.send(formData);
    }
  });

</script>
